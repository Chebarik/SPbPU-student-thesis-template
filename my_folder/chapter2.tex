\chapter{Критерии сравнения и подбор инструментальных средств} \label{ch2}

В данной главе представлены критерии сравнения инструментальных средств для разработки backend-системы управления процессами развертывания и управления пакетами, а также результаты сравнительного анализа и обоснование выбора технологий.

\section{Формирование критериев сравнения} \label{ch2:sec1}

Для сравнения инструментальных средств сформулированы следующие критерии~\cite{bass-devops, shahin-cicd-review}:

\textbf{Критерий 1: Производительность и масштабируемость.} Данный критерий оценивает способность технологии обрабатывать высокие нагрузки, возможность горизонтального масштабирования и оптимизацию для работы с большими объёмами данных. Для системы управления процессами развертывания производительность критична при обработке множества одновременных запросов от клиентов и рабочих узлов.

\textbf{Критерий 2: Зрелость и стабильность.} Критерий учитывает время существования технологии на рынке, наличие стабильных релизов и долгосрочной поддержки, отсутствие критических ошибок в production-окружении и историю успешного использования в аналогичных системах.

\textbf{Критерий 3: Поддержка технологии.} Оценивается частота обновлений и патчей безопасности, качество и актуальность документации, наличие примеров использования и лучших практик.

\textbf{Критерий 4: Интеграция с экосистемой.} Критерий определяет совместимость с другими компонентами технологического стека, простоту интеграции между компонентами, готовые примеры с реализованной интеграцией.

\textbf{Критерий 5: Лицензирование и открытость.} В соответствии с целью создания Open Source решения оценивается наличие открытого исходного кода, отсутствие ограничений для коммерческого использования и возможность самостоятельного развертывания (self-hosted).

\textbf{Критерий 6: Сложность внедрения и обучения.} Критерий учитывает простоту настройки и конфигурации, наличие обучающих материалов и требования к инфраструктуре.

\textbf{Критерий 7: Функциональность для задач системы.} Оценивается соответствие специфическим требованиям подсистемы управления процессами и пакетами, наличие необходимых функций и возможность расширения.


\section{Сравнительный анализ и выбор языка программирования} \label{ch2:sec2}

Для разработки backend-системы рассмотрены следующие варианты языков программирования: C\# (.NET), Java (Spring Boot), Python (FastAPI), Go (Golang).

\textbf{C\# (.NET)} демонстрирует положительные оценки по всем критериям. Платформа .NET обеспечивает высокую производительность, сравнимую с Java и превосходящую Python. Начиная с версии .NET 8.0, поддерживается компиляция в нативный код через AOT (Ahead-of-Time), что обеспечивает производительность, близкую к Go. C\# имеет первоклассную поддержку асинхронных паттернов (async/await), что идеально подходит для I/O-интенсивных операций~\cite{stateless-lib}.

\textbf{Java (Spring Boot)} также демонстрирует высокие показатели производительности и зрелости. Однако экосистема Spring Boot характеризуется большей сложностью настройки и традиционно ассоциируется с более высоким потреблением памяти. Многословный синтаксис Java увеличивает объём кода по сравнению с C\#, а отсутствие нативной поддержки value types приводит к дополнительным накладным расходам на boxing/unboxing.

\textbf{Python (FastAPI)} уступает C\# и Java в производительности вследствие интерпретируемой природы языка. Динамическая типизация увеличивает риск ошибок времени выполнения, что критично для системы управления процессами развертывания. Кроме того, GIL (Global Interpreter Lock) ограничивает возможности многопоточной обработки, что является существенным недостатком для высоконагруженной системы.

\textbf{Go (Golang)} обеспечивает отличную производительность и низкое потребление памяти, однако имеет более ограниченную экосистему библиотек для реализации сложной бизнес-логики. Отсутствие generics до версии 1.18 и минималистичная система типов усложняют создание типобезопасных абстракций для конечных автоматов. Также отсутствует зрелая библиотека для FSM, сопоставимая по функциональности со Stateless.

В качестве языка программирования выбран \textbf{C\# (.NET)} по следующим основаниям:
\begin{itemize}
    \item высокая производительность с поддержкой async/await для асинхронных операций;
    \item богатая экосистема библиотек (ASP.NET Core, Entity Framework Core, StackExchange.Redis);
    \item наличие библиотеки Stateless для реализации конечных автоматов с типобезопасным API~\cite{stateless-lib};
    \item открытый исходный код платформы .NET (лицензия MIT);
    \item кроссплатформенность (Windows, Linux, macOS).
\end{itemize}


\section{Сравнительный анализ и выбор СУБД} \label{ch2:sec3}

Для хранения данных о процессах, пакетах и метаданных рассмотрены следующие варианты: PostgreSQL, Microsoft SQL Server, MySQL, SQLite.

\textbf{PostgreSQL} демонстрирует положительные оценки по всем критериям, кроме того, распространяется под открытой лицензией PostgreSQL License. PostgreSQL предоставляет отличную поддержку JSON и JSONB типов данных, что критично для хранения метаданных пакетов в гибком формате~\cite{pinckney-semver}.

\textbf{Microsoft SQL Server} обеспечивает высокую производительность и функциональность, однако имеет лицензионные ограничения для коммерческого использования, что противоречит требованию Open Source. Express-версия имеет ограничения по размеру базы данных (10 ГБ) и использованию памяти, чего недостаточно для требуемой системы.

\textbf{MySQL} является открытым решением с хорошей производительностью, однако уступает PostgreSQL в поддержке сложных типов данных и возможностях расширения. Поддержка JSON в MySQL менее развита: отсутствует бинарный формат JSONB, индексация JSON-полей ограничена, а производительность JSON-операций ниже. Кроме того, MySQL находится под контролем Oracle, что создаёт риски для долгосрочного развития.

\textbf{SQLite} не подходит для многопользовательской системы из-за ограничений по масштабированию и отсутствия поддержки параллельных записей. SQLite является встраиваемой базой данных без клиент-серверной архитектуры, что делает невозможным горизонтальное масштабирование и распределённое развертывание.

В качестве СУБД выбран \textbf{PostgreSQL} по следующим основаниям:
\begin{itemize}
    \item открытый исходный код с лицензией, допускающей коммерческое использование;
    \item поддержка JSON/JSONB типов для гибкого хранения метаданных;
    \item высокая производительность и поддержка партиционирования;
    \item полная поддержка ACID-транзакций;
    \item отличная интеграция с Entity Framework Core через Npgsql.
\end{itemize}


\section{Сравнительный анализ и выбор ORM} \label{ch2:sec4}

Для работы с базой данных рассмотрены следующие варианты: Entity Framework Core, Dapper, NHibernate, ADO.NET.

\textbf{Entity Framework Core} является официальным ORM от Microsoft с регулярными обновлениями и отличной интеграцией с экосистемой .NET. Предоставляет мощную систему миграций, поддержку LINQ и отличную работу с JSON-типами PostgreSQL.

\textbf{Dapper} обеспечивает более высокую производительность за счёт минимальных абстракций, однако не предоставляет встроенной поддержки миграций и требует написания SQL-запросов вручную. Это увеличивает сложность разработки и поддержки, а также повышает риск ошибок при изменении схемы базы данных.

\textbf{NHibernate} является зрелым ORM с богатой функциональностью, однако имеет более сложную конфигурацию и менее активное развитие по сравнению с Entity Framework Core. Документация устарела, а сообщество значительно меньше.

\textbf{ADO.NET} предоставляет низкоуровневый доступ к базе данных без ORM-абстракций. Требует ручного маппинга данных, не предоставляет типобезопасных запросов и миграций, что существенно увеличивает объём кода и вероятность ошибок.

В качестве ORM выбран \textbf{Entity Framework Core} по следующим основаниям:
\begin{itemize}
    \item официальная поддержка Microsoft с регулярными обновлениями;
    \item мощная система миграций для версионирования схемы базы данных;
    \item поддержка LINQ с типобезопасными запросами;
    \item отличная поддержка JSON типов PostgreSQL;
    \item интеграция с ASP.NET Core через Dependency Injection.
\end{itemize}


\section{Сравнительный анализ и выбор библиотеки для конечных автоматов} \label{ch2:sec5}

Для реализации конечных автоматов рассмотрены следующие варианты: Stateless, Automatonymous (MassTransit), Custom Implementation (своя реализация), WorkflowCore.

\textbf{Stateless} предоставляет простой и интуитивный API для декларативного описания состояний и переходов с типобезопасностью через generic-типы C\#~\cite{stateless-lib}.

\textbf{Automatonymous (MassTransit)} предоставляет больше возможностей (иерархические состояния, встроенная персистентность), однако более сложна в освоении и ориентирована на интеграцию с message bus. Требует обязательного использования MassTransit, что создаёт избыточную зависимость для системы, не использующей этот message broker.

\textbf{Custom Implementation} позволяет создать решение, полностью соответствующее требованиям, однако требует значительных временных затрат на разработку и тестирование. Высок риск ошибок в реализации критически важной логики управления состояниями.

\textbf{WorkflowCore} ориентирован на долгоживущие бизнес-процессы с персистентным состоянием, однако имеет избыточную сложность для задачи управления процессами развертывания. Использует концепцию workflow definition, которая отличается от классической модели FSM и усложняет верификацию формальных свойств.

В качестве библиотеки для реализации конечных автоматов выбрана \textbf{Stateless}~\cite{stateless-lib} по следующим основаниям:
\begin{itemize}
    \item простой и интуитивный API для декларативного описания состояний и переходов;
    \item типобезопасность через generic-типы C\# для состояний и триггеров;
    \item поддержка guard-условий для реализации блокировок этапов;
    \item поддержка действий при входе и выходе из состояний;
    \item открытый исходный код (лицензия Apache 2.0);
    \item лёгкая интеграция с Entity Framework Core для персистентности состояний.
\end{itemize}


\section{Сравнительный анализ и выбор системы кэширования} \label{ch2:sec6}

Для распределённого кэширования метаданных пакетов и состояний процессов рассмотрены следующие варианты: Redis, Memcached, Hazelcast, In-memory кэш .NET.

\textbf{Redis} представляет собой высокопроизводительное in-memory хранилище с богатым набором структур данных и поддержкой distributed locks~\cite{redis-docs}.

\textbf{Memcached} представляет собой высокопроизводительную систему кэширования с простым интерфейсом key-value. В отличие от Redis, Memcached не поддерживает сложные структуры данных (hashes, lists, sets), персистентность и distributed locks, что критично для системы управления процессами. Отсутствие поддержки Redlock делает невозможной надёжную координацию между узлами.

\textbf{Hazelcast} представляет собой платформу in-memory computing с поддержкой распределённых структур данных и вычислений. Система предоставляет более широкую функциональность по сравнению с Redis, однако требует больших ресурсов, имеет более сложную конфигурацию и меньшее сообщество. Избыточная функциональность увеличивает операционную сложность без существенных преимуществ для рассматриваемой системы.

\textbf{In-memory кэш .NET} (IMemoryCache) не подходит для распределённой системы, так как кэш локален для каждого экземпляра приложения. Это приводит к несогласованности данных между узлами и невозможности масштабирования.

В качестве системы кэширования выбран \textbf{Redis}~\cite{redis-docs} по следующим основаниям:
\begin{itemize}
    \item высокая производительность (сотни тысяч операций в секунду);
    \item богатый набор структур данных (strings, hashes, lists, sets, sorted sets);
    \item поддержка distributed locks через алгоритм Redlock;
    \item поддержка персистентности данных (RDB, AOF);
    \item поддержка кластеризации и репликации;
    \item открытый исходный код (лицензия BSD);
    \item отличная интеграция с .NET через StackExchange.Redis.
\end{itemize}

Redis будет использоваться для:
\begin{enumerate}
    \item кэширования метаданных пакетов для ускорения поиска;
    \item распределённого кэширования состояний процессов;
    \item реализации distributed locks для предотвращения конфликтов при параллельных переходах FSM;
    \item хранения индексов для быстрого поиска пакетов.
\end{enumerate}


\section{Сравнительный анализ и выбор системы очередей сообщений} \label{ch2:sec7}

Для асинхронной обработки задач и координации между компонентами системы рассмотрены следующие варианты: RabbitMQ, Apache Kafka, Azure Service Bus, Redis Streams.

\textbf{Apache Kafka} представляет собой платформу распределённого стриминга событий с высокой производительностью и гарантиями доставки~\cite{kafka-streaming}.

\textbf{RabbitMQ} проще в настройке и имеет богатую поддержку паттернов маршрутизации сообщений, однако не поддерживает хранение истории событий, что критично для системы управления процессами, где важна возможность воспроизведения событий для анализа и аудита. При высоких нагрузках RabbitMQ демонстрирует меньшую производительность по сравнению с Kafka.

\textbf{Azure Service Bus} является managed-сервисом в облаке Azure с хорошей функциональностью, однако привязка к облачному провайдеру противоречит требованию self-hosted установки и Open Source.

\textbf{Redis Streams} предоставляет базовую функциональность стриминга в рамках Redis, однако уступает Kafka в производительности, масштабируемости и зрелости. Отсутствует поддержка consumer groups с семантикой exactly-once, а также инструменты мониторинга и управления.

В качестве системы очередей сообщений выбран \textbf{Apache Kafka}~\cite{kafka-streaming} по следующим основаниям:
\begin{itemize}
    \item высокая производительность (миллионы сообщений в секунду);
    \item хранение истории событий с возможностью повторной обработки;
    \item строгие гарантии доставки и упорядоченности сообщений в рамках партиции;
    \item поддержка множества независимых consumer groups;
    \item горизонтальное масштабирование через партиционирование;
    \item открытый исходный код (лицензия Apache 2.0);
    \item возможность self-hosted развертывания.
\end{itemize}


\section{Итоговая архитектура технологического стека} \label{ch2:sec8}

По результатам сравнительного анализа сформирован следующий технологический стек:

\begin{itemize}
    \item \textbf{Язык программирования:} C\# (.NET 8.0+)
    \item \textbf{Web-фреймворк:} ASP.NET Core
    \item \textbf{СУБД:} PostgreSQL
    \item \textbf{ORM:} Entity Framework Core
    \item \textbf{Библиотека FSM:} Stateless
    \item \textbf{Система кэширования:} Redis
    \item \textbf{Система очередей:} Apache Kafka
\end{itemize}

Данный стек соответствует всем установленным критериям и ограничениям, обеспечивая:
\begin{enumerate}
    \item высокую производительность и масштабируемость;
    \item открытость исходного кода всех компонентов;
    \item возможность self-hosted развертывания;
    \item формальное описание процессов на основе конечных автоматов;
    \item гибкое хранение метаданных пакетов;
    \item распределённое кэширование и координацию.
\end{enumerate}


\section{Выводы} \label{ch2:conclusion}

По результатам сравнительного анализа и подбора инструментальных средств можно сделать следующие выводы:

\begin{enumerate}
    \item Сформулированы семь критериев сравнения инструментальных средств, учитывающих производительность, зрелость, поддержку, интеграцию, лицензирование, сложность внедрения и функциональность.
 
    \item Выбран технологический стек на основе платформы .NET (C\#, ASP.NET Core, Entity Framework Core), обеспечивающий высокую производительность и богатую экосистему библиотек.
    
    \item Для реализации конечных автоматов выбрана библиотека Stateless, предоставляющая типобезопасный API для декларативного описания состояний и переходов.
    
    \item Для хранения данных выбрана СУБД PostgreSQL с поддержкой JSON/JSONB типов для гибкого хранения метаданных пакетов.
    
    \item Для распределённого кэширования и координации выбран Redis, для асинхронной обработки событий~--- Apache Kafka.
\end{enumerate}


%% Вспомогательные команды - Additional commands
%\newpage % принудительное начало с новой страницы, использовать только в конце раздела
