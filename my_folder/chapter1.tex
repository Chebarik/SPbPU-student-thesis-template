\chapter{Обзор существующих решений и теоретических основ} \label{ch1}

В данной главе представлен обзор существующих исследований и решений в области систем управления процессами развертывания программного обеспечения. Рассматриваются теоретические основы описания процессов на базе конечных автоматов, проводится сравнительный анализ существующих платформ для управления развертыванием и оркестрации, а также исследуются подходы к управлению пакетами артефактов и потоковой передаче логов.

\section{Теоретические основы описания процессов на базе конечных автоматов} \label{ch1:sec1}

\subsection{Основные определения и формальная модель}

Конечный автомат (КА) представляет собой математическую модель вычислительной системы с конечным числом состояний, которая переходит из одного состояния в другое под воздействием входных сигналов~\cite{hopcroft-ullman, sipser-computation}. Формально детерминированный конечный автомат определяется как пятёрка $M = (Q, \Sigma, \delta, q_0, F)$, где:
\begin{itemize}
    \item $Q$ --- конечное множество состояний;
    \item $\Sigma$ --- конечный входной алфавит (множество событий);
    \item $\delta: Q \times \Sigma \rightarrow Q$ --- функция переходов;
    \item $q_0 \in Q$ --- начальное состояние;
    \item $F \subseteq Q$ --- множество финальных (допускающих) состояний.
\end{itemize}

В контексте систем управления процессами развертывания состояния автомата соответствуют этапам процесса (например, <<ожидание>>, <<выполнение>>, <<успех>>, <<ошибка>>, <<откат>>), а входной алфавит~--- множеству событий, инициирующих переходы между этапами (завершение задачи, ошибка выполнения, ручное одобрение и~т.\,д.)~\cite{fsm-habr, weyns-activforms}.

\subsection{Формальные свойства процессов и их применение к процессам развертывания}

При проектировании систем управления процессами развертывания критически важным является обеспечение ряда формальных свойств, гарантирующих корректность и надёжность работы системы~\cite{workflow-patterns, petri-nets}:

\textbf{Безопасность (Safety)} --- гарантия того, что система никогда не попадёт в недопустимое состояние. В контексте развертывания это означает невозможность перехода к следующему этапу без успешного завершения предыдущего, а также невозможность одновременного выполнения несовместимых операций.

\textbf{Живость (Liveness)} --- гарантия того, что система всегда может продолжить выполнение и не зависнет в промежуточном состоянии. Для процессов развертывания это свойство обеспечивает возможность либо успешного завершения процесса, либо его корректного прерывания с откатом изменений.

\textbf{Достижимость (Reachability)} --- свойство, определяющее возможность перехода из начального состояния в целевое состояние. Анализ достижимости позволяет верифицировать корректность определения процесса до его выполнения~\cite{aiswarya-verification, silaev-verification}.

\textbf{Отсутствие тупиков (Deadlock-freedom)} --- гарантия того, что система не может оказаться в состоянии, из которого невозможен ни один переход. Для систем развертывания это критично при организации параллельного выполнения задач и механизмов блокировок.

Исследования показывают, что применение формальных методов верификации на этапе проектирования рабочих процессов позволяет существенно снизить количество ошибок при выполнении процессов развертывания~\cite{silaev-verification, weyns-activforms}. В одной из исследовательских работ был предложен метод верификации автоматных алгоритмов по частичному описанию входных последовательностей, который может быть адаптирован для проверки корректности процессов развертывания~\cite{silaev-verification}.

\subsection{Подходы к описанию состояний и переходов}

На практике при построении систем управления процессами выделяют несколько подходов к описанию состояний и переходов~\cite{fsm-yoomoney, skynet-fsm}:

\textbf{Императивный подход} предполагает явное программирование логики переходов между состояниями с использованием условных конструкций. Данный подход характеризуется высокой гибкостью, однако приводит к сложности поддержки и верификации при увеличении числа состояний.

\textbf{Декларативный подход} основан на описании допустимых переходов в виде конфигурации (таблицы переходов, графа состояний). Этот подход упрощает верификацию и визуализацию процессов, однако требует более сложной инфраструктуры для интерпретации описаний~\cite{bpmn-spec}.

\textbf{Событийно-ориентированный подход} рассматривает переходы как реакцию на события, генерируемые внешними системами или внутренними компонентами. Данный подход хорошо сочетается с микросервисной архитектурой и паттернами событийно-ориентированного программирования~\cite{taibi-devops}.

Современные библиотеки для реализации конечных автоматов, такие как Stateless для платформы~.NET, предоставляют возможность комбинирования указанных подходов: декларативное описание допустимых переходов сочетается с императивным определением действий при входе и выходе из состояний, а также условий (guard conditions) для переходов~\cite{stateless-lib}.


\section{Сравнительный анализ существующих платформ для управления развертыванием} \label{ch1:sec2}

\subsection{Классификация систем управления развертыванием}

Системы управления процессами развертывания можно классифицировать по нескольким признакам~\cite{shahin-cicd-review, rodriguez-orchestration}:

По архитектурному подходу:
\begin{itemize}
    \item централизованные системы с единым сервером управления (Jenkins, TeamCity);
    \item распределённые системы с масштабируемой архитектурой (GitLab CI/CD, GitHub Actions);
    \item cloud-native системы, ориентированные на Kubernetes (Argo CD, Tekton, Spinnaker).
\end{itemize}

По модели описания процессов:
\begin{itemize}
    \item конфигурация через пользовательский интерфейс (Octopus Deploy, Azure DevOps);
    \item конфигурация как код в формате YAML/JSON (GitHub Actions, GitLab CI/CD);
    \item программное определение через DSL или API (Jenkins Pipeline, Tekton).
\end{itemize}

По степени интеграции с инфраструктурой:
\begin{itemize}
    \item универсальные платформы (Jenkins, GitLab CI/CD);
    \item платформы, привязанные к облачному провайдеру (AWS CodePipeline, Azure DevOps);
    \item платформы для конкретной экосистемы (Argo CD для Kubernetes).
\end{itemize}

\subsection{Обзор ключевых платформ}

\textbf{Jenkins} является одной из наиболее распространённых open-source платформ для автоматизации CI/CD~\cite{jenkins-handbook}. Архитектура Jenkins основана на концепции master-agent, где центральный сервер координирует выполнение задач на распределённых агентах. Jenkins Pipeline предоставляет возможность описания процессов в виде кода на языке Groovy, поддерживая как декларативный, так и скриптовый синтаксис. К достоинствам Jenkins относятся обширная экосистема плагинов и высокая гибкость настройки. Однако система характеризуется сложностью администрирования, отсутствием встроенной модели конечных автоматов для описания процессов и ограниченными возможностями горизонтального масштабирования.

\textbf{GitLab CI/CD} представляет собой интегрированную систему непрерывной интеграции и доставки, встроенную в платформу GitLab~\cite{gitlab-cicd-docs}. Процессы описываются в файле \texttt{.gitlab-ci.yml} в декларативном формате YAML. GitLab CI/CD поддерживает концепцию stages (этапов), jobs (задач) и pipelines (конвейеров), позволяя организовать как последовательное, так и параллельное выполнение задач. Система предоставляет встроенную поддержку manual approval через механизм manual jobs, однако не имеет формальной модели конечных автоматов для описания сложных ветвлений и условных переходов.

\textbf{GitHub Actions} предлагает событийно-ориентированную модель автоматизации, где процессы запускаются в ответ на события в репозитории (например, push, pull request, release и др.)~\cite{github-actions-docs}. Система поддерживает декларативное описание процессов в формате YAML с возможностью определения зависимостей между выполняемыми работами. К достоинствам относятся тесная интеграция с экосистемой GitHub и обширную площадку с готовыми вариантами автоматизации. Ограничениями являются привязка к платформе GitHub и отсутствие поддержки сложных процессов с множественными условными переходами.

\textbf{Octopus Deploy} представляет собой специализированную платформу для управления релизами и развертыванием~\cite{octopus-packages}. Система предоставляет развитую модель управления процессами с поддержкой environments (сред развертывания), lifecycles (жизненных циклов) и channels (каналов). Octopus Deploy реализует концепцию deployment process как последовательности шагов с поддержкой условного выполнения. Подсистема управления пакетами поддерживает различные форматы артефактов и интеграцию с внешними репозиториями. Ограничением является проприетарная лицензия и необходимость приобретения коммерческой версии для получения доступа ко всему функционалу Octopus.

\textbf{AWS CodePipeline} предоставляет сервис непрерывной доставки для AWS-инфраструктуры~\cite{aws-codepipeline-approval}. Система поддерживает модель pipeline, состоящего из различных этапов и действий, с возможностью добавления необходимости вручную подтвержать определенное действие для критических этапов. CodePipeline интегрируется с другими сервисами AWS (CodeBuild, CodeDeploy, S3, Lambda), обеспечивая полный цикл CI/CD в облачной среде. Ограничением является привязка к экосистеме AWS.

\textbf{Azure DevOps Pipelines} предлагает комплексное решение для CI/CD с поддержкой YAML-based pipelines и классических релизных pipelines~\cite{azure-devops-approvals}. Система поддерживает среды развертывания с настраиваемыми подтверждениями и проверками, различными стратегиями деплоя (rolling, canary, blue-green) и интеграцию с Azure-сервисами.

\textbf{Argo CD} представляет собой декларативный инструмент непрерывной доставки для Kubernetes, реализующий паттерн GitOps~\cite{argocd-docs}. Система отслеживает состояние приложений в Git-репозитории и автоматически синхронизирует его с состоянием кластера Kubernetes. Argo CD предоставляет визуализацию состояния приложений, поддержку откатов и ручной синхронизации. Ограничением является ориентация исключительно на Kubernetes.

\textbf{Spinnaker} разработан компанией Netflix как платформа для мультиоблачной непрерывной поставки~\cite{spinnaker-docs}. Система предоставляет модель pipeline со стадиями различных типов (deploy, manual judgment, wait, webhook и др.), поддержку различных стратегий развертывания и интеграцию с различными облачными провайдерами.

\subsection{Сравнительный анализ подходов к описанию процессов}

Систематический анализ существующих платформ позволяет выявить следующие закономерности в подходах к описанию процессов развертывания~\cite{taibi-devops, lwakatare-devops}:

Большинство современных платформ используют декларативный подход к описанию процессов в формате YAML или JSON, что обеспечивает версионирование конфигурации совместно с кодом приложения (Infrastructure as Code, Pipeline as Code). Однако декларативные форматы имеют ограничения при описании сложных условных переходов и циклов.

Механизмы ручного одобрения (manual approval) присутствуют в большинстве платформ, однако их реализация существенно различается~--- от простых manual jobs в GitLab CI/CD до сложных approval gates с множественными условиями в Azure DevOps.

Формальная модель конечных автоматов для описания процессов в явном виде не используется ни в одной из рассмотренных платформ. Процессы представляются либо как последовательность шагов с условиями, либо как направленный граф (DAG) зависимостей между задачами. Это ограничивает возможности верификации корректности процессов и усложняет моделирование сложных сценариев с откатами и повторными попытками.

Интеграция подсистем управления процессами и управления пакетами реализована по-разному: полная интеграция в Octopus Deploy; использование внешних репозиториев артефактов в Jenkins и GitLab CI/CD.

\section{Системы управления пакетами артефактов} \label{ch1:sec3}

\subsection{Форматы упаковки артефактов развертывания}

Артефакты развертывания могут быть представлены в различных форматах в зависимости от технологического стека и требований процесса~\cite{octopus-packages, humble-cd}:

\textbf{Архивные форматы} (ZIP, TAR, TAR.GZ) представляют собой универсальный способ упаковки файлов без специфичной для платформы метаинформации. Достоинством является простота создания и распаковки, недостатком~--- отсутствие стандартизированных механизмов версионирования и описания зависимостей.

\textbf{Platform-specific пакеты} включают форматы, специфичные для конкретных пакетных менеджеров: NuGet (.nupkg) для .NET, npm для JavaScript, PyPI для Python, Maven для Java~\cite{nuget-docs}. Данные форматы предоставляют стандартизированную структуру метаданных, механизмы версионирования и разрешения зависимостей.

\textbf{Container images} (Docker, OCI) представляют собой формат упаковки приложений вместе с их runtime-окружением~\cite{docker-registry}. Контейнерные образы обеспечивают воспроизводимость развертывания и изоляцию приложений, однако требуют инфраструктуры для хранения и запуска контейнеров.

\textbf{Helm charts} представляют собой формат упаковки приложений для Kubernetes, включающий шаблоны манифестов и конфигурацию~\cite{rodriguez-orchestration}. Helm обеспечивает параметризацию развертывания и управление релизами в Kubernetes-среде.

\subsection{Системы хранения и версионирования пакетов}

Для хранения артефактов развертывания используются специализированные репозитории пакетов~\cite{artifactory-docs, nexus-docs}:

\textbf{JFrog Artifactory} представляет собой универсальный репозиторий артефактов с поддержкой более 30 форматов пакетов~\cite{artifactory-docs}. Система предоставляет механизмы репликации, кэширования, контроля доступа и интеграции с CI/CD платформами. Artifactory поддерживает метаданные пакетов в формате JSON с возможностью кастомных полей и запросов через AQL (Artifactory Query Language).

\textbf{Sonatype Nexus Repository} предоставляет функциональность хранения и проксирования пакетов различных форматов~\cite{nexus-docs}. Система поддерживает hosted (локальные), proxy (проксирующие) и group (объединяющие) репозитории, обеспечивая гибкую организацию хранения артефактов.

\textbf{GitHub Packages} и \textbf{GitLab Container Registry} предоставляют интегрированные решения для хранения пакетов в рамках соответствующих платформ~\cite{github-packages}. Достоинством является тесная интеграция с системами контроля версий и CI/CD, недостатком~--- привязка к конкретной платформе.

\subsection{Стратегии версионирования пакетов}

Семантическое версионирование (SemVer) является де-факто стандартом версионирования программных пакетов~\cite{semver-spec, pinckney-semver}. Формат версии MAJOR.MINOR.PATCH определяет правила изменения номеров: MAJOR увеличивается при несовместимых изменениях API, MINOR~--- при добавлении обратно совместимой функциональности, PATCH~--- при исправлении ошибок.

Исследования показали, что в экосистеме npm около 40\% пакетов не соблюдают строго правила семантического версионирования, что приводит к проблемам совместимости при обновлении зависимостей~\cite{pinckney-semver}. Также важно учитывать pre-release версии (0.y.z), т.к. они оказывают большое влияние на стабильность зависимостей~\cite{decan-versioning}.

Для систем управления развертыванием важным является не только версионирование пакетов, но и версионирование процессов развертывания, что позволяет обеспечить воспроизводимость и возможность отката к предыдущим версиям процессов.

\section{Технологии распределённого кэширования и координации} \label{ch1:sec4}

\subsection{Системы распределённого кэширования}

Для обеспечения высокой производительности систем управления пакетами необходимо использование распределённого кэширования метаданных~\cite{redis-docs}:

\textbf{Redis} представляет собой in-memory хранилище данных с поддержкой различных структур (strings, hashes, lists, sets, sorted sets, streams)~\cite{redis-docs}. Redis обеспечивает высокую производительность (сотни тысяч операций в секунду), поддержку distributed locks через алгоритм Redlock, персистентность данных через RDB и AOF, кластеризацию и репликацию.

\textbf{Memcached} представляет собой высокопроизводительную систему кэширования с простым интерфейсом key-value. В отличие от Redis, Memcached не поддерживает сложные структуры данных, персистентность и distributed locks, однако обеспечивает несколько большую производительность для простых операций.

\textbf{Hazelcast} представляет собой платформу in-memory computing с поддержкой распределённых структур данных, вычислений и кэширования. Система предоставляет более широкую функциональность по сравнению с Redis, однако требует больших ресурсов и имеет более сложную конфигурацию.

\subsection{Системы распределённой координации}

Для обеспечения согласованности в распределённых системах управления процессами необходимы механизмы координации~\cite{consul-docs}:

\textbf{HashiCorp Consul} предоставляет функциональность service discovery, distributed key-value store и service mesh~\cite{consul-docs}. Consul обеспечивает консистентность данных через протокол Raft и может использоваться для хранения конфигурации, координации между узлами и реализации distributed locks.

\textbf{etcd} представляет собой распределённое key-value хранилище, используемое в Kubernetes для хранения состояния кластера. etcd обеспечивает строгую консистентность через протокол Raft и watch API для отслеживания изменений.

\textbf{Apache ZooKeeper} является системой координации для распределённых приложений, предоставляющей примитивы для синхронизации, конфигурирования и именования. ZooKeeper широко используется в экосистеме Apache (Kafka, Hadoop) и обеспечивает строгую консистентность данных.


\section{Технологии потоковой передачи логов} \label{ch1:sec5}

\subsection{Подходы к сбору и агрегации логов}

Для обеспечения наблюдаемости процессов развертывания необходимы механизмы сбора, агрегации и потоковой передачи логов выполнения~\cite{kafka-streaming}:

\textbf{WebSocket} --- это протокол, позволяющий серверу и клиенту обмениваться сообщениями в обе стороны через одно постоянное соединение~\cite{websocket-rfc}. Благодаря этому логи могут передаваться практически мгновенно, но соединение должно оставаться открытым на протяжении всего сеанса.

\textbf{Server-Sent Events (SSE)} представляет собой технологию однонаправленной передачи данных от сервера к клиенту через HTTP~\cite{sse-spec}. SSE проще в реализации по сравнению с WebSocket, поддерживает автоматическое переподключение, однако обеспечивает только однонаправленную связь.

\textbf{Apache Kafka} представляет собой платформу распределённого стриминга событий с высокой производительностью и гарантиями доставки~\cite{kafka-streaming}. Kafka обеспечивает хранение истории событий, поддержку множества потребителей и горизонтальное масштабирование. Для систем управления процессами Kafka может использоваться как для асинхронной обработки событий, так и для потоковой передачи логов.

\subsection{Архитектурные паттерны для стриминга логов}

При проектировании подсистемы стриминга логов необходимо учитывать следующие архитектурные паттерны~\cite{bass-devops, kim-devops-handbook}:

\textbf{Log aggregation} предполагает сбор логов с распределённых worker-узлов в централизованное хранилище для последующего анализа и поиска. Для реализации могут использоваться агенты (Filebeat, Fluentd) и централизованные системы (Elasticsearch, Loki).

\textbf{Real-time log streaming} обеспечивает передачу логов в реальном времени для отображения прогресса выполнения процессов. Требует организации push-модели передачи данных через WebSocket или SSE.

\textbf{Log retention и archiving} определяет политики хранения и архивирования логов для обеспечения возможности анализа исторических данных и аудита операций.


\section{Выводы} \label{ch1:conclusion}

По результатам обзора существующих решений и теоретических основ можно сделать следующие выводы:

\begin{enumerate}
    \item Теория конечных автоматов предоставляет формальный аппарат для описания процессов развертывания, обеспечивающий возможность верификации корректности, анализа достижимости состояний и гарантии формальных свойств (безопасность, живость, отсутствие тупиков).
    
    \item Существующие CI/CD платформы (Jenkins, GitLab CI/CD, GitHub Actions, Octopus Deploy) не используют формальную модель конечных автоматов в явном виде, представляя процессы как последовательность шагов или направленный граф. Это ограничивает возможности верификации и моделирования сложных сценариев.
    
    \item Механизмы ручного одобрения присутствуют в большинстве платформ, однако их реализация существенно различается и не всегда интегрирована с моделью состояний процесса.
    
    \item Системы управления пакетами (Artifactory, Nexus, GitHub Packages) предоставляют функциональность хранения и версионирования артефактов, однако их интеграция с системами управления процессами реализована на различном уровне.
    
    \item Для обеспечения масштабируемости и производительности систем управления пакетами необходимо использование распределённого кэширования (Redis) и механизмов координации (Consul, etcd).
    
    \item Технологии потоковой передачи логов (WebSocket, SSE, Kafka) обеспечивают возможность мониторинга выполнения процессов в реальном времени и сохранения истории для аудита.
\end{enumerate}


%% Вспомогательные команды - Additional commands
%\newpage % принудительное начало с новой страницы, использовать только в конце раздела

